\d .ml

// Execution of a pipeline will not default to enter q debug mode but should 
//  be possible to overwrite
graphDebug:0b

// @kind function
// @category pipeline
// @fileoverview Update debugging mode
// @return {null} Debugging is updated
updDebug:{[]graphDebug::not graphDebug}

// @kind function
// @category pipeline
// @fileoverview Generate a execution pipeline based on a valid graph
// @param graph {dict} Graph originally generated by .ml.createGraph, which 
//   has all relevant input edges connected validly
// @return {dict} An optimal execution pipeline populated with all information
//   required to allow its successful execution 
createPipeline:{[graph]
  if[not all exec 1_valid from graph`edges;'"disconnected edges"];
  outputs:ungroup select srcNode:nodeId,srcName:key each outputs 
    from 1_graph`nodes;
  srcInfo:select srcNode,srcName from graph`edges;
  endPoints:exec distinct srcNode from outputs except srcInfo;
  paths:i.getOptimalPath[graph]each endPoints;
  optimalPath:distinct raze paths idesc count each paths;
  pipeline:([]nodeId:optimalPath)#graph`nodes;
  nodeInputs:key each exec inputs from pipeline;
  pipeline:update inputs:count[i]#enlist(1#`)!1#(::),outputTypes:outputs,
    inputOrder:nodeInputs from pipeline;
  pipeline:select nodeId,complete:0b,error:`,function,inputs,outputs:inputs,
     outputTypes,inputOrder from pipeline;
  pipeline:pipeline lj select outputmap:([]srcName;destNode;destName)by 
    nodeId:srcNode from graph`edges;
  1!pipeline}

// @kind function
// @category pipeline
// @fileoverview Execute a generated pipeline
// @param pipeline {dict} Pipeline created by .ml.createPipeline
// @return {dict} The pipeline with each node executed and appropriate outputs
//   populated.
execPipeline:{[pipeline]i.execCheck i.execNext/pipeline}
