\d .ml

// Graphing creation utilities

// @kind function
// @category pipelineUtility
// @fileoverview Connect the output of one node to the input to another 
// @param graph {dict} Graph originally generated by .ml.createGraph, which 
//   has all relevant input edges connected validly
// @param edge {dict} Contains information about the edge node
// @return {dict} The graph with the relevant connection made between the 
//   inputs and outputs of two nodes.
i.connectGraph:{[graph;edge]
  connectEdge[graph]. edge`srcNode`srcName`destNode`destName
  }

// Pipeline creation utilities

// @kind function
// @category pipelineUtility
// @fileoverview Extract the source of a specific node 
// @param graph {dict} Graph originally generated by .ml.createGraph, which 
//   has all relevant input edges connected validly
// @param node {sym} Name associated with the functional node
// @return {sym} Source of the given node
i.getDeps:{[graph;node]
   exec distinct srcNode from graph[`edges]where destNode=node
   }

// @kind function
// @category pipelineUtility
// @fileoverview Extract all dependent source nodes needed to run the node
// @param graph {dict} Graph originally generated by .ml.createGraph, which 
//   has all relevant input edges connected validly
// @param node {sym} Denoting the name to be associated with the functional 
//   node
// @return {sym[]} All sources required for the given node  
i.getAllDeps:{[graph;node]
  $[count depNodes:i.getDeps[graph]node;
    distinct node,raze .z.s[graph]each depNodes;
    node]
   }

// @kind function
// @category pipelineUtility
// @fileoverview  Extract all the paths needed to run the node
// @param graph {dict} Graph originally generated by .ml.createGraph, which 
//   has all relevant input edges connected validly
// @param node {sym} Denoting the name to be associated with the functional 
//   node
// @return {sym} All paths required for the given node
i.getAllPaths:{[graph;node]
  $[count depNodes:i.getDeps[graph]node;
   node,/:raze .z.s[graph]each depNodes;
   raze node]
   }

// @kind function
// @category pipelineUtility
// @fileoverview Get the longest path
// @param graph {dict} Graph originally generated by .ml.createGraph, which 
//   has all relevant input edges connected validly
// @param node {sym} Denoting the name to be associated with the functional 
//   node
// @return {sym} The longest path available
i.getLongestPath:{[graph;node]
  paths:reverse each i.getAllPaths[graph;node];
  paths first idesc count each paths
  }

// @kind function
// @category pipelineUtility
// @fileoverview Extract the optimal path to run the node
// @param graph {dict} Graph originally generated by .ml.createGraph, which 
//   has all relevant input edges connected validly
// @param node {sym} Denoting the name to be associated with the functional 
//   node
// @return {sym} The optimal path to run the node
i.getOptimalPath:{[graph;node]
  longestPath:i.getLongestPath[graph;node];
  distinct raze reverse each i.getAllDeps[graph]each longestPath
  }


// @kind function
// @category pipelineUtility
// @fileoverview Update input data information within the pipeline
// @param pipeline {dict} Pipeline created by .ml.createPipeline
// @param map {dict} Contains information needed to run the node
// @return {dict} Pipeline updated with input information
i.updateInputData:{[pipeline;map]
  pipeline[map`destNode;`inputs;map`destName]:map`data;
  pipeline
  }

// @kind function
// @category pipelineUtility
// @fileoverview Execute the first non completed node in the pipeline
// @param pipeline {dict} Pipeline created by .ml.createPipeline
// @return {dict} Pipeline with executed node marked as complete
i.execNext:{[pipeline]
  node:first 0!select from pipeline where not complete;
  -1"Executing node: ",string node`nodeId;
  if[not count inputs:node[`inputs]node[`inputOrder];inputs:1#(::)];
  resKeys:`complete`error`outputs;
  resVals:$[graphDebug;
      .[(1b;`;)node[`function]::;inputs];
      .[(1b;`;)node[`function]::;inputs;{[err](0b;`$err;::)}]
      ];
  res:resKeys!resVals;
  / compare outputs to outputtypes ?
  if[not null res`error;-2"Error: ",string res`error];
  if[res`complete;
    res[`inputs]:(1#`)!1#(::);
    outputMap:update data:res[`outputs]srcName from node`outputmap;
    res[`outputs]:((1#`)!1#(::)),
     (exec distinct srcName from outputMap)_ res`outputs;
    pipeline:i.updateInputData/[pipeline;outputMap];
  ];
  pipeline,:update nodeId:node`nodeId from res;
  pipeline}

// @kind function
// @category pipelineUtility
// @fileoverview Check if any nodes are left to be executed or if any
//   errors have occured
// @param pipeline {dict} Pipeline created by .ml.createPipeline
// @return {dict} Return 0b if all nodes have been completed or if any errors
//   have occured. Otherwise return 1b
i.execCheck:{[pipeline]
  if[any not null exec error from pipeline;:0b];
  if[all exec complete from pipeline;:0b];
  1b}
